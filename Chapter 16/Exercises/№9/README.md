#### Глава - 16, Задание - 9 ####

По сравнению с массивом связный список отличается более простым
добавлением и удалением элементов, но медленной сортировкой. Поэтому возникает
вопрос: возможно, было бы быстрее скопировать список в массив, отсортировать
массив и скопировать отсортированный результат обратно в список, чем просто
использовать алгоритм списка для сортировки. (Но это может быть связано с
наличием большего объема памяти.) Проверьте гипотезу о более быстром
выполнении задачи, применив следующий подход.

***A*** - Создайте большой объект ```ѵі0``` типа ```vector<int>```, используя ```rand()``` для
задания начальных значений.

***B*** - Создайте второй объект ```ѵі``` типа ```vector<int>``` и объект ```1і``` типа ```list<int>```
того же размера, что и исходный, и инициализируйте их значениями
исходного вектора.

***C*** - Замерьте время, требуемое программе для сортировки ```ѵі``` с помощью
алгоритма ```sort()``` из ```STL```, а затем время, необходимое для сортировки ```1і```
посредством метода ```list``` ```sort()```.

***D*** - Переустановите ```1і``` неотсортированным содержимым ѵіО. Замерьте время
выполнения смешанной операции копирования ```1і``` в ```ѵі```, сортировки ```ѵі``` и
копирования результата обратно в ```1і```.

Для измерения времени выполнения этих операций можно использовать
```clock()``` из библиотеки ```ctime```. Как показано в листинге ```5.14```, для запуска
первого таймера можно применять следующий оператор:

```objectivec
clock_t start = clock();
```

Для получения прошедшего времени в конце операции используйте следующий
оператор:

```objectivec
clock_t end = clock();
cout << (double)(end - start)/CLOCKS_PER_SEC;
```

Вне всяких сомнений, этот тест показателен, поскольку результаты будут
зависеть от ряда факторов, в том числе объема доступной памяти, применения
многопроцессорной обработки и размеров массива или списка. (С
увеличением количества сортируемых элементов можно ожидать большего увеличения
эффективности массива по сравнению со списком.) Кроме того, при наличии
выбора между стандартной сборкой и окончательной сборкой, следует
выбирать окончательную сборку. В современных высокоскоростных компьютерах
для получения репрезентативных результатов необходимо использовать массив
максимально возможного размера. Например, можно иметь 100 000, 1 000 000 и
10 000 000 элементов.

=================================================================================
#### Вывод ####
```objectivec
0.341
```